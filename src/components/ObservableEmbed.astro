---
interface Props {
  modulePath: string;
  exportName: string;
  options?: Record<string, unknown>;
}

const {modulePath, exportName, options = {}} = Astro.props;
const serializedOptions = JSON.stringify(options);
---

<div class="observable-embed-host" data-module-path={modulePath} data-export-name={exportName} data-options={serializedOptions}></div>
<script is:inline data-astro-rerun>
  (() => {
    const root = document.currentScript?.previousElementSibling;
    if (!(root instanceof HTMLElement)) return;

    const modulePath = root.dataset.modulePath;
    const exportName = root.dataset.exportName;
    const options = JSON.parse(root.dataset.options || "{}");

    if (!modulePath || !exportName) return;

    const state = (window.__observableEmbedState = window.__observableEmbedState || {mounted: 0, errors: []});
    let mountedNode = null;
    let mountPromise = null;
    let disposed = false;

    function teardownMountedNode() {
      if (!mountedNode) return;
      mountedNode.remove();
      mountedNode = null;
      state.mounted = Math.max(0, state.mounted - 1);
    }

    async function mountIfNeeded() {
      if (disposed || mountedNode || mountPromise || !document.body.contains(root)) return;
      try {
        mountPromise = (async () => {
          const mod = await import(/* @vite-ignore */ modulePath);
          const renderFn = mod[exportName];
          if (typeof renderFn !== "function") {
            throw new Error(`Export ${exportName} is not a function`);
          }

          const node = await renderFn(options);
          if (!(node instanceof Element)) {
            throw new Error(`Export ${exportName} did not return a DOM node`);
          }

          if (disposed || !document.body.contains(root)) return;
          mountedNode = node;
          root.appendChild(node);
          state.mounted += 1;
        })();
        await mountPromise;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        state.errors.push({modulePath, exportName, message});
        root.innerHTML = `<p class="embed-error">Embed failed: ${message}</p>`;
      } finally {
        mountPromise = null;
      }
    }

    function handleBeforeSwap() {
      // During client-side navigation we teardown to avoid stale DOM and
      // then remount on the next page-load/pageshow event if this host returns.
      teardownMountedNode();
    }

    function remountAfterNavigation() {
      void mountIfNeeded();
    }

    function dispose() {
      if (disposed) return;
      disposed = true;
      teardownMountedNode();
      observer.disconnect();
      document.removeEventListener("astro:before-swap", handleBeforeSwap);
      document.removeEventListener("astro:page-load", remountAfterNavigation);
      window.removeEventListener("pageshow", remountAfterNavigation);
      window.removeEventListener("beforeunload", dispose);
    }

    const observer = new MutationObserver(() => {
      if (!document.body.contains(root)) {
        dispose();
      }
    });
    observer.observe(document.body, {childList: true, subtree: true});

    document.addEventListener("astro:before-swap", handleBeforeSwap);
    document.addEventListener("astro:page-load", remountAfterNavigation);
    window.addEventListener("pageshow", remountAfterNavigation);
    window.addEventListener("beforeunload", dispose, {once: true});

    void mountIfNeeded();
  })();
</script>

<style>
  .observable-embed-host {
    width: 100%;
    display: block;
  }

  .embed-error {
    margin: 0;
    padding: 0.75rem;
    border: 1px dashed #7f2f2f;
    border-radius: 8px;
    color: #ffb6b6;
    background: #2a1111;
  }
</style>
